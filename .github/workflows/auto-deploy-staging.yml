name: Auto Deploy to Staging (develop branch)

on:
  # Trigger when any service repository's develop branch is updated
  repository_dispatch:
    types: [deploy-staging]
  
  # Manual trigger for testing
  workflow_dispatch:
    inputs:
      service_name:
        description: 'Service to deploy (leave empty for webhook trigger)'
        required: false
        type: string
      service_repo:
        description: 'Service repository URL (leave empty for webhook trigger)'
        required: false
        type: string

env:
  DEPLOY_PATH: '/opt/letzgo'

jobs:
  # ===========================================================================
  # Deploy Service to Staging
  # ===========================================================================
  deploy-staging:
    name: Deploy to Staging Environment
    runs-on: ubuntu-latest
    environment: 
      name: staging
      url: http://103.168.19.241
    
    steps:
      - name: Checkout deployment repository
        uses: actions/checkout@v4

      - name: Parse webhook payload
        id: parse
        run: |
          # Get service info from webhook payload or manual input
          if [ "${{ github.event_name }}" = "repository_dispatch" ]; then
            SERVICE_NAME="${{ github.event.client_payload.service_name }}"
            SERVICE_REPO="${{ github.event.client_payload.service_repo }}"
            SERVICE_BRANCH="${{ github.event.client_payload.service_branch || 'develop' }}"
            COMMIT_SHA="${{ github.event.client_payload.commit_sha }}"
          else
            SERVICE_NAME="${{ github.event.inputs.service_name }}"
            SERVICE_REPO="${{ github.event.inputs.service_repo }}"
            SERVICE_BRANCH="develop"
            COMMIT_SHA="latest"
          fi
          
          echo "service_name=$SERVICE_NAME" >> $GITHUB_OUTPUT
          echo "service_repo=$SERVICE_REPO" >> $GITHUB_OUTPUT
          echo "service_branch=$SERVICE_BRANCH" >> $GITHUB_OUTPUT
          echo "commit_sha=$COMMIT_SHA" >> $GITHUB_OUTPUT
          
          echo "Deploying service: $SERVICE_NAME"
          echo "Repository: $SERVICE_REPO"
          echo "Branch: $SERVICE_BRANCH"
          echo "Commit: $COMMIT_SHA"

      - name: Checkout service repository
        uses: actions/checkout@v4
        with:
          repository: ${{ steps.parse.outputs.service_repo }}
          ref: ${{ steps.parse.outputs.service_branch }}
          token: ${{ secrets.DEPLOYMENT_TOKEN }}
          path: service-code

      - name: Detect package manager
        id: detect-pm
        run: |
          cd service-code
          
          # Prioritize Yarn as requested
          if [ -f "yarn.lock" ]; then
            echo "pm=yarn" >> $GITHUB_OUTPUT
            echo "cache=yarn" >> $GITHUB_OUTPUT
            echo "cache-path=service-code/yarn.lock" >> $GITHUB_OUTPUT
            echo "install-cmd=yarn install --frozen-lockfile" >> $GITHUB_OUTPUT
          elif [ -f "package.json" ]; then
            # Use yarn by default for all repos as requested
            echo "pm=yarn" >> $GITHUB_OUTPUT
            echo "cache=" >> $GITHUB_OUTPUT
            echo "cache-path=" >> $GITHUB_OUTPUT
            echo "install-cmd=yarn install" >> $GITHUB_OUTPUT
          else
            # Fallback to npm if no package.json
            echo "pm=npm" >> $GITHUB_OUTPUT
            echo "cache=" >> $GITHUB_OUTPUT
            echo "cache-path=" >> $GITHUB_OUTPUT
            echo "install-cmd=npm install" >> $GITHUB_OUTPUT
          fi
          
          echo "Detected package manager: $(cat $GITHUB_OUTPUT | grep pm=)"

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: ${{ steps.detect-pm.outputs.cache }}
          cache-dependency-path: ${{ steps.detect-pm.outputs.cache-path }}
        if: steps.detect-pm.outputs.cache != ''

      - name: Setup Node.js (no cache)
        uses: actions/setup-node@v4
        with:
          node-version: '20'
        if: steps.detect-pm.outputs.cache == ''

      - name: Install dependencies
        run: |
          cd service-code
          ${{ steps.detect-pm.outputs.install-cmd }}

      - name: Run tests
        run: |
          cd service-code
          if [ "${{ steps.detect-pm.outputs.pm }}" = "yarn" ]; then
            yarn test || echo "No tests or tests failed for ${{ steps.parse.outputs.service_name }}"
          else
            npm test || echo "No tests or tests failed for ${{ steps.parse.outputs.service_name }}"
          fi

      - name: Build Docker image
        run: |
          cd service-code
          
          # Create Dockerfile if it doesn't exist
          if [ ! -f "Dockerfile" ]; then
            echo "Creating default Dockerfile for ${{ steps.parse.outputs.service_name }}"
            cat > Dockerfile << 'EOF'
          FROM node:20-alpine
          
          WORKDIR /app
          
          # Copy package files
          COPY package*.json ./
          COPY yarn.lock ./
          
          # Install dependencies with yarn
          RUN yarn install --frozen-lockfile --production
          
          # Copy source code
          COPY . .
          
          # Create logs directory
          RUN mkdir -p logs
          
          # Create non-root user for security
          RUN addgroup -g 1001 -S nodejs && \
              adduser -S appuser -u 1001 -G nodejs
          
          # Change ownership
          RUN chown -R appuser:nodejs /app
          USER appuser
          
          # Expose port
          EXPOSE 3000
          
          # Health check
          HEALTHCHECK --interval=30s --timeout=10s --start-period=5s --retries=3 \
            CMD curl -f http://localhost:3000/health || exit 1
          
          # Start application
          CMD ["node", "src/server.js"]
          EOF
          fi
          
          # Build Docker image
          echo "üê≥ Building Docker image for ${{ steps.parse.outputs.service_name }}..."
          docker build -t letzgo-${{ steps.parse.outputs.service_name }}:staging .
          
          # Verify image was created
          docker images | grep letzgo-${{ steps.parse.outputs.service_name }}
          
          # Save image as artifact with compression and validation
          echo "üì¶ Saving Docker image to tar archive..."
          docker save letzgo-${{ steps.parse.outputs.service_name }}:staging | gzip > ../service-image.tar.gz
          
          # Verify tar file was created and is valid
          echo "üîç Validating tar archive..."
          cd ..
          if [ ! -f "service-image.tar.gz" ]; then
            echo "‚ùå Error: service-image.tar.gz was not created"
            exit 1
          fi
          
          # Check file size (should be > 0 bytes)
          FILE_SIZE=$(stat -c%s service-image.tar.gz 2>/dev/null || stat -f%z service-image.tar.gz)
          echo "üìä Archive size: $FILE_SIZE bytes"
          
          if [ "$FILE_SIZE" -eq 0 ]; then
            echo "‚ùå Error: Archive is empty"
            exit 1
          fi
          
          # Test tar file integrity
          if ! gzip -t service-image.tar.gz; then
            echo "‚ùå Error: Archive is corrupted"
            exit 1
          fi
          
          echo "‚úÖ Docker image saved and validated successfully"

      - name: Setup SSH
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.VPS_SSH_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          ssh-keyscan -p ${{ secrets.VPS_PORT }} ${{ secrets.VPS_HOST }} >> ~/.ssh/known_hosts

      - name: Copy Docker image to VPS
        run: |
          echo "üì§ Copying Docker image to VPS..."
          
          # Verify file exists before transfer
          if [ ! -f "service-image.tar.gz" ]; then
            echo "‚ùå Error: service-image.tar.gz not found"
            exit 1
          fi
          
          # Show file size before transfer
          ls -lh service-image.tar.gz
          
          # Transfer with verbose output and verification
          scp -P ${{ secrets.VPS_PORT }} -o StrictHostKeyChecking=no -v \
            service-image.tar.gz \
            ${{ secrets.VPS_USER }}@${{ secrets.VPS_HOST }}:/tmp/
          
          echo "‚úÖ Docker image transferred successfully"

      - name: Deploy service on VPS
        run: |
          ssh -p ${{ secrets.VPS_PORT }} -o StrictHostKeyChecking=no \
            ${{ secrets.VPS_USER }}@${{ secrets.VPS_HOST }} << 'EOF'
          
          set -e
          
          SERVICE_NAME="${{ steps.parse.outputs.service_name }}"
          
          echo "üöÄ Deploying \$SERVICE_NAME to staging from develop branch..."
          
          # Verify compressed tar file exists and is valid
          if [ ! -f "/tmp/service-image.tar.gz" ]; then
            echo "‚ùå Error: /tmp/service-image.tar.gz not found on VPS"
            exit 1
          fi
          
          echo "üìä Archive info:"
          ls -lh /tmp/service-image.tar.gz
          
          # Test archive integrity
          if ! gzip -t /tmp/service-image.tar.gz; then
            echo "‚ùå Error: Archive is corrupted"
            exit 1
          fi
          
          # Load Docker image from compressed archive
          echo "üì¶ Loading Docker image from compressed archive..."
          gunzip -c /tmp/service-image.tar.gz | docker load
          
          # Verify image was loaded
          docker images | grep letzgo-\$SERVICE_NAME || {
            echo "‚ùå Error: Docker image not found after loading"
            exit 1
          }
          
          # Ensure Docker network exists (robust; supports compose-prefixed name)
          echo "üîç Checking Docker network status..."
          NETWORK_NAME="letzgo-network"
          if docker network ls --format "{{.Name}}" | grep -q "^letzgo_letzgo-network$"; then
            NETWORK_NAME="letzgo_letzgo-network"
          elif docker network ls --format "{{.Name}}" | grep -q "^letzgo-network$"; then
            NETWORK_NAME="letzgo-network"
          else
            echo "üîó Creating letzgo-network..."
            docker network create letzgo-network
            NETWORK_NAME="letzgo-network"
          fi
          
          # Verify chosen network is accessible
          if ! docker network inspect "$NETWORK_NAME" >/dev/null 2>&1; then
            echo "‚ùå Error: network '$NETWORK_NAME' not accessible"
            echo "üìã Available networks:"
            docker network ls
            exit 1
          fi
          echo "üîó Using network: $NETWORK_NAME"
          
          # Stop existing container if running
          docker stop letzgo-\$SERVICE_NAME || true
          docker rm letzgo-\$SERVICE_NAME || true
          
          # Load environment variables
          cd "${{ env.DEPLOY_PATH }}"
          if [ -f ".env" ]; then
            set -a
            source .env
            set +a
          else
            echo "‚ùå Environment file not found!"
            exit 1
          fi
          
          # Determine service port
          case "\$SERVICE_NAME" in
            "auth-service") PORT=3000 ;;
            "user-service") PORT=3001 ;;
            "chat-service") PORT=3002 ;;
            "event-service") PORT=3003 ;;
            "shared-service") PORT=3004 ;;
            "splitz-service") PORT=3005 ;;
            *) echo "Unknown service: \$SERVICE_NAME"; exit 1 ;;
          esac
          
          # Run new container
          docker run -d \
            --name letzgo-\$SERVICE_NAME \
            --network "$NETWORK_NAME" \
            -p \$PORT:\$PORT \
            --env-file .env \
            -e NODE_ENV=staging \
            -e PORT=\$PORT \
            -v "${{ env.DEPLOY_PATH }}/logs:/app/logs" \
            -v "${{ env.DEPLOY_PATH }}/uploads:/app/uploads" \
            --restart unless-stopped \
            letzgo-\$SERVICE_NAME:staging
          
          echo "‚úÖ \$SERVICE_NAME deployed successfully to staging!"
          
          # Clean up compressed image file
          rm -f /tmp/service-image.tar.gz
          
          # Show running containers
          echo "üìã Running containers:"
          docker ps | grep letzgo-\$SERVICE_NAME
          EOF

      - name: Wait for service to be healthy
        run: |
          ssh -p ${{ secrets.VPS_PORT }} -o StrictHostKeyChecking=no \
            ${{ secrets.VPS_USER }}@${{ secrets.VPS_HOST }} << 'EOF'
          
          SERVICE_NAME="${{ steps.parse.outputs.service_name }}"
          
          case "\$SERVICE_NAME" in
            "auth-service") PORT=3000 ;;
            "user-service") PORT=3001 ;;
            "chat-service") PORT=3002 ;;
            "event-service") PORT=3003 ;;
            "shared-service") PORT=3004 ;;
            "splitz-service") PORT=3005 ;;
          esac
          
          echo "‚è≥ Waiting for \$SERVICE_NAME to be healthy on port \$PORT..."
          
          max_attempts=30
          attempt=1
          
          while [ \$attempt -le \$max_attempts ]; do
            if curl -f -s http://localhost:\$PORT/health > /dev/null 2>&1; then
              echo "‚úÖ \$SERVICE_NAME is healthy on staging!"
              break
            fi
            
            if [ \$attempt -eq \$max_attempts ]; then
              echo "‚ùå \$SERVICE_NAME failed to become healthy on staging"
              docker logs letzgo-\$SERVICE_NAME --tail 50
              exit 1
            fi
            
            echo "Attempt \$attempt/\$max_attempts - waiting 10 seconds..."
            sleep 10
            attempt=\$((attempt + 1))
          done
          EOF

      - name: Cleanup SSH
        if: always()
        run: |
          rm -f ~/.ssh/id_rsa

      - name: Notify deployment success
        run: |
          echo "‚úÖ Staging deployment successful!"
          echo "Service: ${{ steps.parse.outputs.service_name }}"
          echo "Branch: ${{ steps.parse.outputs.service_branch }}"
          echo "Environment: staging"
          echo "VPS: http://103.168.19.241"
