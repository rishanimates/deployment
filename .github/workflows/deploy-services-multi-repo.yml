name: üöÄ Deploy Services (Multiple Repositories)

on:
  workflow_dispatch:
    inputs:
      repositories:
        description: 'Repositories to deploy (comma-separated): auth-service,user-service,chat-service,event-service,shared-service,splitz-service'
        required: true
        default: 'auth-service,user-service,chat-service,event-service,shared-service,splitz-service'
        type: string
      branch:
        description: 'Branch to deploy from each repository'
        required: true
        default: 'main'
        type: choice
        options:
          - main
          - develop
          - staging
          - master
      environment:
        description: 'Target environment'
        required: true
        default: 'staging'
        type: choice
        options:
          - staging
          - production
      force_rebuild:
        description: 'Force rebuild Docker images'
        required: false
        default: false
        type: boolean

jobs:
  deploy-services:
    name: Deploy ${{ matrix.service }}
    runs-on: ubuntu-latest
    environment: ${{ github.event.inputs.environment }}
    strategy:
      fail-fast: false
      matrix:
        service: ["auth-service", "user-service", "chat-service", "event-service", "shared-service", "splitz-service"]
    
    steps:
      - name: Parse repositories input
        id: parse-repos
        run: |
          # Convert comma-separated string to array
          REPOS="${{ github.event.inputs.repositories }}"
          if [[ "$REPOS" == *"${{ matrix.service }}"* ]]; then
            echo "deploy=true" >> $GITHUB_OUTPUT
          else
            echo "deploy=false" >> $GITHUB_OUTPUT
          fi

      - name: Skip if not in deployment list
        if: steps.parse-repos.outputs.deploy == 'false'
        run: |
          echo "‚è≠Ô∏è Skipping ${{ matrix.service }} - not in deployment list"
          exit 0

      - name: Setup SSH
        if: steps.parse-repos.outputs.deploy == 'true'
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.VPS_SSH_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          ssh-keyscan -p ${{ secrets.VPS_PORT }} ${{ secrets.VPS_HOST }} >> ~/.ssh/known_hosts

      - name: Deploy ${{ matrix.service }}
        if: steps.parse-repos.outputs.deploy == 'true'
        run: |
          ssh -p ${{ secrets.VPS_PORT }} -o StrictHostKeyChecking=no \
            ${{ secrets.VPS_USER }}@${{ secrets.VPS_HOST }} << 'DEPLOY_EOF'
          
          set -e
          
          # Configuration
          SERVICE="${{ matrix.service }}"
          BRANCH="${{ github.event.inputs.branch }}"
          ENVIRONMENT="${{ github.event.inputs.environment }}"
          FORCE_REBUILD="${{ github.event.inputs.force_rebuild }}"
          
          DEPLOY_PATH="/opt/letzgo"
          SERVICES_PATH="$DEPLOY_PATH/services"
          SERVICE_PATH="$SERVICES_PATH/$SERVICE"
          
          # Service ports mapping
          declare -A SERVICE_PORTS=(
            ["auth-service"]="3000"
            ["user-service"]="3001"
            ["chat-service"]="3002"
            ["event-service"]="3003"
            ["shared-service"]="3004"
            ["splitz-service"]="3005"
          )
          
          PORT="${SERVICE_PORTS[$SERVICE]}"
          
          echo "üöÄ Deploying $SERVICE from $BRANCH branch to $ENVIRONMENT"
          echo "üìç Port: $PORT"
          echo ""
          
          # Create services directory
          mkdir -p "$SERVICES_PATH"
          cd "$SERVICES_PATH"
          
          # Ensure GitHub is in known_hosts
          if ! grep -q "github.com" ~/.ssh/known_hosts 2>/dev/null; then
            ssh-keyscan github.com >> ~/.ssh/known_hosts 2>/dev/null || echo "Failed to add GitHub to known_hosts"
          fi
          
          # Clone or update repository
          if [ -d "$SERVICE_PATH" ]; then
            echo "üì• Updating existing $SERVICE repository..."
            cd "$SERVICE_PATH"
            git fetch origin || true
            git checkout "$BRANCH" || git checkout main || true
            git pull origin "$BRANCH" || git pull origin main || echo "‚ö†Ô∏è Pull failed, continuing with existing code"
          else
            echo "üì• Cloning $SERVICE repository..."
            # Try SSH first (for private repos with SSH key)
            if git clone "git@github.com:rhushirajpatil/$SERVICE.git" "$SERVICE_PATH" 2>/dev/null; then
              echo "‚úÖ Cloned via SSH"
              cd "$SERVICE_PATH"
              git checkout "$BRANCH" || git checkout main || echo "‚ö†Ô∏è Branch checkout failed"
            else
              echo "‚ö†Ô∏è SSH clone failed, creating basic service structure..."
              
              # Create basic service structure as fallback
              mkdir -p "$SERVICE_PATH/src"
              cd "$SERVICE_PATH"
              
              # Initialize git repo
              git init
              
              # Create basic package.json
              cat > package.json << PACKAGE_EOF
{
  "name": "$SERVICE",
  "version": "1.0.0",
  "description": "LetzGo $SERVICE microservice",
  "main": "src/app.js",
  "scripts": {
    "start": "node src/app.js"
  },
  "dependencies": {
    "express": "^4.18.2",
    "cors": "^2.8.5",
    "helmet": "^7.0.0",
    "swagger-ui-express": "^5.0.0",
    "swagger-jsdoc": "^6.2.8"
  }
}
PACKAGE_EOF

              # Create basic app.js with Swagger
              cat > src/app.js << 'APP_EOF'
const express = require('express');
const cors = require('cors');
const helmet = require('helmet');
const swaggerJsdoc = require('swagger-jsdoc');
const swaggerUi = require('swagger-ui-express');

const app = express();
const PORT = process.env.PORT || 3000;

// Swagger configuration
const swaggerOptions = {
  definition: {
    openapi: '3.0.0',
    info: {
      title: 'LetzGo Service API',
      version: '1.0.0',
      description: 'API documentation for LetzGo microservice'
    },
    servers: [
      {
        url: \`http://103.168.19.241:\${PORT}\`,
        description: 'Staging server'
      },
      {
        url: \`http://localhost:\${PORT}\`,
        description: 'Development server'
      }
    ]
  },
  apis: ['./src/*.js']
};

const swaggerSpec = swaggerJsdoc(swaggerOptions);

app.use(helmet());
app.use(cors());
app.use(express.json());

// Swagger documentation
app.use('/api-docs', swaggerUi.serve, swaggerUi.setup(swaggerSpec));

app.get('/health', (req, res) => {
    res.json({
        status: 'ok',
        service: process.env.SERVICE_NAME || 'service',
        version: '1.0.0',
        timestamp: new Date().toISOString(),
        port: PORT
    });
});

app.get('/', (req, res) => {
    res.json({
        message: 'LetzGo service is running',
        version: '1.0.0',
        endpoints: {
            health: '/health',
            documentation: '/api-docs'
        }
    });
});

app.listen(PORT, '0.0.0.0', () => {
    console.log(\`üöÄ Service listening on port \${PORT}\`);
    console.log(\`üìö API docs: http://103.168.19.241:\${PORT}/api-docs\`);
});
APP_EOF

              # Create Dockerfile
              cat > Dockerfile << 'DOCKER_EOF'
FROM node:20-alpine

WORKDIR /app

COPY package*.json ./
RUN npm install --production

COPY . .

EXPOSE 3000

HEALTHCHECK --interval=30s --timeout=10s --start-period=60s --retries=3 \
  CMD curl -f http://localhost:3000/health || exit 1

CMD ["npm", "start"]
DOCKER_EOF

              git add .
              git commit -m "Initial service structure with Swagger" || echo "Commit successful"
              
              echo "‚úÖ Created basic $SERVICE structure with Swagger"
            fi
          fi
          
          cd "$SERVICE_PATH"
          
          # Install dependencies
          echo "ÔøΩÔøΩ Installing dependencies..."
          if command -v yarn &> /dev/null; then
            yarn install --production
          else
            npm install --production
          fi
          
          # Build Docker image
          echo "üê≥ Building Docker image for $SERVICE..."
          
          if [ "$FORCE_REBUILD" = "true" ]; then
            docker build --no-cache -t "letzgo-$SERVICE:latest" .
          else
            docker build -t "letzgo-$SERVICE:latest" .
          fi
          
          # Stop and remove existing container
          echo "üîÑ Stopping existing $SERVICE container..."
          docker stop "letzgo-$SERVICE" 2>/dev/null || true
          docker rm "letzgo-$SERVICE" 2>/dev/null || true
          
          # Run new container
          echo "üöÄ Starting $SERVICE container..."
          docker run -d \
            --name "letzgo-$SERVICE" \
            --network letzgo-network \
            --restart unless-stopped \
            -p "$PORT:$PORT" \
            -e NODE_ENV="$ENVIRONMENT" \
            -e PORT="$PORT" \
            -e HOST="0.0.0.0" \
            "letzgo-$SERVICE:latest"
          
          # Wait for service to be healthy
          echo "‚è≥ Waiting for $SERVICE to be healthy..."
          for i in {1..12}; do
            if curl -f -s --connect-timeout 5 "http://localhost:$PORT/health" >/dev/null 2>&1; then
              echo "‚úÖ $SERVICE is healthy!"
              break
            fi
            if [ $i -eq 12 ]; then
              echo "‚ùå $SERVICE failed to become healthy"
              exit 1
            fi
            echo "‚è≥ Attempt $i/12 - waiting 10 seconds..."
            sleep 10
          done
          
          echo "üéâ $SERVICE deployment completed successfully!"
          echo "üîó Service URL: http://103.168.19.241:$PORT"
          echo "üìö API Documentation: http://103.168.19.241:$PORT/api-docs"
          
          DEPLOY_EOF

      - name: Cleanup SSH
        if: always()
        run: rm -f ~/.ssh/id_rsa
