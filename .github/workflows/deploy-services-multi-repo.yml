name: Deploy Services (Multi-Repository)

on:
  workflow_dispatch:
    inputs:
      services:
        description: 'Services to deploy (comma-separated: auth-service,user-service,chat-service,event-service,shared-service,splitz-service)'
        required: true
        default: 'all'
        type: string
      service_branches:
        description: 'Branches to deploy (format: auth-service:main,user-service:develop). Leave empty to use develop for all'
        required: false
        type: string
      environment:
        description: 'Deployment environment'
        required: true
        default: 'staging'
        type: choice
        options:
        - staging
        - production

env:
  DEPLOY_PATH: '/opt/letzgo'

jobs:
  # ===========================================================================
  # Setup Service Configuration
  # ===========================================================================
  setup:
    name: Setup Service Configuration
    runs-on: ubuntu-latest
    outputs:
      matrix: ${{ steps.config.outputs.matrix }}
      services: ${{ steps.config.outputs.services }}
    
    steps:
      - name: Configure service repositories
        id: config
        run: |
          # Define service repository mappings
          # Update these URLs to match your actual repositories
          declare -A SERVICE_REPOS=(
            ["auth-service"]="rishanimates/auth-service"
            ["user-service"]="rishanimates/user-service"
            ["chat-service"]="rishanimates/chat-service"
            ["event-service"]="rishanimates/event-service"
            ["shared-service"]="rishanimates/shared-service"
            ["splitz-service"]="rishanimates/splitz-service"
          )
          
          # Parse service branches input
          declare -A SERVICE_BRANCHES
          if [ -n "${{ github.event.inputs.service_branches }}" ]; then
            IFS=',' read -ra BRANCH_PAIRS <<< "${{ github.event.inputs.service_branches }}"
            for pair in "${BRANCH_PAIRS[@]}"; do
              service=$(echo "$pair" | cut -d':' -f1)
              branch=$(echo "$pair" | cut -d':' -f2)
              SERVICE_BRANCHES["$service"]="$branch"
            done
          fi
          
          # Determine services to deploy
          if [ "${{ github.event.inputs.services }}" = "all" ]; then
            SERVICES="auth-service,user-service,chat-service,event-service,shared-service,splitz-service"
          else
            SERVICES="${{ github.event.inputs.services }}"
          fi
          
          # Create matrix configuration
          MATRIX_SERVICES=""
          IFS=',' read -ra SERVICE_ARRAY <<< "$SERVICES"
          
          for service in "${SERVICE_ARRAY[@]}"; do
            repo_url="${SERVICE_REPOS[$service]}"
            branch="${SERVICE_BRANCHES[$service]:-develop}"
            
            if [ -n "$repo_url" ]; then
              if [ -n "$MATRIX_SERVICES" ]; then
                MATRIX_SERVICES="$MATRIX_SERVICES,"
              fi
              MATRIX_SERVICES="$MATRIX_SERVICES{\"service\":\"$service\",\"repo\":\"$repo_url\",\"branch\":\"$branch\"}"
            else
              echo "Warning: No repository configured for $service"
            fi
          done
          
          echo "services=$SERVICES" >> $GITHUB_OUTPUT
          echo "matrix={\"include\":[$MATRIX_SERVICES]}" >> $GITHUB_OUTPUT
          
          echo "Services to deploy: $SERVICES"
          echo "Matrix: {\"include\":[$MATRIX_SERVICES]}"

  # ===========================================================================
  # Build Services from Separate Repositories
  # ===========================================================================
  build:
    name: Build Service
    runs-on: ubuntu-latest
    needs: setup
    if: needs.setup.outputs.services != ''
    
    strategy:
      matrix: ${{ fromJson(needs.setup.outputs.matrix) }}
      fail-fast: false
    
    steps:
      - name: Checkout ${{ matrix.service }} repository
        uses: actions/checkout@v4
        with:
          repository: ${{ matrix.repo }}
          ref: ${{ matrix.branch }}
          token: ${{ secrets.DEPLOYMENT_TOKEN }}
          path: ${{ matrix.service }}

      - name: Detect package manager
        id: detect-pm
        run: |
          cd ${{ matrix.service }}
          
          # Prioritize Yarn as requested
          if [ -f "yarn.lock" ]; then
            echo "pm=yarn" >> $GITHUB_OUTPUT
            echo "cache=yarn" >> $GITHUB_OUTPUT
            echo "cache-path=${{ matrix.service }}/yarn.lock" >> $GITHUB_OUTPUT
            echo "install-cmd=yarn install --frozen-lockfile" >> $GITHUB_OUTPUT
          elif [ -f "package.json" ]; then
            # Use yarn by default for all repos as requested
            echo "pm=yarn" >> $GITHUB_OUTPUT
            echo "cache=" >> $GITHUB_OUTPUT
            echo "cache-path=" >> $GITHUB_OUTPUT
            echo "install-cmd=yarn install" >> $GITHUB_OUTPUT
          else
            # Fallback to npm if no package.json
            echo "pm=npm" >> $GITHUB_OUTPUT
            echo "cache=" >> $GITHUB_OUTPUT
            echo "cache-path=" >> $GITHUB_OUTPUT
            echo "install-cmd=npm install" >> $GITHUB_OUTPUT
          fi
          
          echo "Detected package manager for ${{ matrix.service }}: $(cat $GITHUB_OUTPUT | grep pm=)"

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: ${{ steps.detect-pm.outputs.cache }}
          cache-dependency-path: ${{ steps.detect-pm.outputs.cache-path }}
        if: steps.detect-pm.outputs.cache != ''

      - name: Setup Node.js (no cache)
        uses: actions/setup-node@v4
        with:
          node-version: '20'
        if: steps.detect-pm.outputs.cache == ''

      - name: Install dependencies for ${{ matrix.service }}
        run: |
          cd ${{ matrix.service }}
          ${{ steps.detect-pm.outputs.install-cmd }}

      - name: Run tests for ${{ matrix.service }}
        run: |
          cd ${{ matrix.service }}
          if [ "${{ steps.detect-pm.outputs.pm }}" = "yarn" ]; then
            yarn test || echo "No tests or tests failed for ${{ matrix.service }}"
          else
            npm test || echo "No tests or tests failed for ${{ matrix.service }}"
          fi

      - name: Build Docker image for ${{ matrix.service }}
        run: |
          cd ${{ matrix.service }}
          
          # Create Dockerfile if it doesn't exist
          if [ ! -f "Dockerfile" ]; then
            echo "Creating default Dockerfile for ${{ matrix.service }}"
            cat > Dockerfile << 'EOF'
          FROM node:20-alpine
          
          WORKDIR /app
          
          # Copy package files
          COPY package*.json ./
          
          # Install dependencies
          RUN npm ci --only=production
          
          # Copy source code
          COPY . .
          
          # Create logs directory
          RUN mkdir -p logs
          
          # Expose port
          EXPOSE 3000
          
          # Health check
          HEALTHCHECK --interval=30s --timeout=10s --start-period=5s --retries=3 \
            CMD curl -f http://localhost:3000/health || exit 1
          
          # Start application
          CMD ["npm", "start"]
          EOF
          fi
          
          # Build Docker image
          docker build -t letzgo-${{ matrix.service }}:latest .
          
          # Save image as artifact with compression and validation
          echo "üì¶ Saving Docker image to tar archive..."
          docker save letzgo-${{ matrix.service }}:latest | gzip > ../letzgo-${{ matrix.service }}-image.tar.gz
          
          # Verify tar file was created and is valid
          echo "üîç Validating tar archive..."
          cd ..
          if [ ! -f "letzgo-${{ matrix.service }}-image.tar.gz" ]; then
            echo "‚ùå Error: letzgo-${{ matrix.service }}-image.tar.gz was not created"
            exit 1
          fi
          
          # Check file size (should be > 0 bytes)
          FILE_SIZE=$(stat -c%s letzgo-${{ matrix.service }}-image.tar.gz 2>/dev/null || stat -f%z letzgo-${{ matrix.service }}-image.tar.gz)
          echo "üìä Archive size: $FILE_SIZE bytes"
          
          if [ "$FILE_SIZE" -eq 0 ]; then
            echo "‚ùå Error: Archive is empty"
            exit 1
          fi
          
          # Test tar file integrity
          if ! gzip -t letzgo-${{ matrix.service }}-image.tar.gz; then
            echo "‚ùå Error: Archive is corrupted"
            exit 1
          fi
          
          echo "‚úÖ Docker image saved and validated successfully"

      - name: Upload Docker image
        uses: actions/upload-artifact@v4
        with:
          name: letzgo-${{ matrix.service }}-image
          path: letzgo-${{ matrix.service }}-image.tar.gz
          retention-days: 1

  # ===========================================================================
  # Deploy Services to VPS
  # ===========================================================================
  deploy:
    name: Deploy Services to VPS
    runs-on: ubuntu-latest
    needs: [setup, build]
    if: needs.setup.outputs.services != ''
    environment: 
      name: staging
      url: http://103.168.19.241
    
    strategy:
      matrix: ${{ fromJson(needs.setup.outputs.matrix) }}
      fail-fast: false
      max-parallel: 2
    
    steps:
      - name: Download Docker image for ${{ matrix.service }}
        uses: actions/download-artifact@v4
        with:
          name: letzgo-${{ matrix.service }}-image

      - name: Setup SSH
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.VPS_SSH_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          ssh-keyscan -p ${{ secrets.VPS_PORT }} ${{ secrets.VPS_HOST }} >> ~/.ssh/known_hosts

      - name: Copy Docker image to VPS
        run: |
          echo "üì§ Copying Docker image to VPS..."
          
          # Verify file exists before transfer
          if [ ! -f "letzgo-${{ matrix.service }}-image.tar.gz" ]; then
            echo "‚ùå Error: letzgo-${{ matrix.service }}-image.tar.gz not found"
            exit 1
          fi
          
          # Show file size before transfer
          ls -lh letzgo-${{ matrix.service }}-image.tar.gz
          
          # Transfer with verbose output and verification
          scp -P ${{ secrets.VPS_PORT }} -o StrictHostKeyChecking=no -v \
            letzgo-${{ matrix.service }}-image.tar.gz \
            ${{ secrets.VPS_USER }}@${{ secrets.VPS_HOST }}:/tmp/
          
          echo "‚úÖ Docker image transferred successfully"

      - name: Deploy ${{ matrix.service }} on VPS
        run: |
          ssh -p ${{ secrets.VPS_PORT }} -o StrictHostKeyChecking=no \
            ${{ secrets.VPS_USER }}@${{ secrets.VPS_HOST }} << 'EOF'
          
          set -e
          
          echo "üöÄ Deploying ${{ matrix.service }} from repository ${{ matrix.repo }}..."
          
          # Verify compressed tar file exists and is valid
          if [ ! -f "/tmp/letzgo-${{ matrix.service }}-image.tar.gz" ]; then
            echo "‚ùå Error: /tmp/letzgo-${{ matrix.service }}-image.tar.gz not found on VPS"
            exit 1
          fi
          
          echo "üìä Archive info:"
          ls -lh /tmp/letzgo-${{ matrix.service }}-image.tar.gz
          
          # Test archive integrity
          if ! gzip -t /tmp/letzgo-${{ matrix.service }}-image.tar.gz; then
            echo "‚ùå Error: Archive is corrupted"
            exit 1
          fi
          
          # Load Docker image from compressed archive
          echo "üì¶ Loading Docker image from compressed archive..."
          gunzip -c /tmp/letzgo-${{ matrix.service }}-image.tar.gz | docker load
          
          # Verify image was loaded
          docker images | grep letzgo-${{ matrix.service }} || {
            echo "‚ùå Error: Docker image not found after loading"
            exit 1
          }
          
          # Ensure Docker network exists (robust; supports compose-prefixed name)
          echo "üîç Checking Docker network status..."
          NETWORK_NAME="letzgo-network"
          if docker network ls --format "{{.Name}}" | grep -q "^letzgo_letzgo-network$"; then
            NETWORK_NAME="letzgo_letzgo-network"
          elif docker network ls --format "{{.Name}}" | grep -q "^letzgo-network$"; then
            NETWORK_NAME="letzgo-network"
          else
            echo "üîó Creating letzgo-network..."
            docker network create letzgo-network
            NETWORK_NAME="letzgo-network"
          fi
          
          # Verify chosen network is accessible
          if ! docker network inspect "$NETWORK_NAME" >/dev/null 2>&1; then
            echo "‚ùå Error: network '$NETWORK_NAME' not accessible"
            echo "üìã Available networks:"
            docker network ls
            exit 1
          fi
          echo "üîó Using network: $NETWORK_NAME"
          
          # Stop existing container if running
          docker stop letzgo-${{ matrix.service }} || true
          docker rm letzgo-${{ matrix.service }} || true
          
          # Load environment variables
          cd "${{ env.DEPLOY_PATH }}"
          if [ -f ".env" ]; then
            set -a
            source .env
            set +a
          else
            echo "‚ùå Environment file not found!"
            exit 1
          fi
          
          # Determine service port
          case "${{ matrix.service }}" in
            "auth-service") PORT=3000 ;;
            "user-service") PORT=3001 ;;
            "chat-service") PORT=3002 ;;
            "event-service") PORT=3003 ;;
            "shared-service") PORT=3004 ;;
            "splitz-service") PORT=3005 ;;
            *) echo "Unknown service: ${{ matrix.service }}"; exit 1 ;;
          esac
          
          # Run new container
          docker run -d \
            --name letzgo-${{ matrix.service }} \
            --network "$NETWORK_NAME" \
            -p $PORT:$PORT \
            --env-file .env \
            -e NODE_ENV=staging \
            -e PORT=$PORT \
            -v "${{ env.DEPLOY_PATH }}/logs:/app/logs" \
            -v "${{ env.DEPLOY_PATH }}/uploads:/app/uploads" \
            --restart unless-stopped \
            letzgo-${{ matrix.service }}:latest
          
          echo "‚úÖ ${{ matrix.service }} deployed successfully from ${{ matrix.repo }}!"
          
          # Clean up compressed image file
          rm -f /tmp/letzgo-${{ matrix.service }}-image.tar.gz
          
          # Show running containers
          echo "üìã Running containers:"
          docker ps | grep letzgo-${{ matrix.service }}
          EOF

      - name: Wait for ${{ matrix.service }} to be healthy
        run: |
          ssh -p ${{ secrets.VPS_PORT }} -o StrictHostKeyChecking=no \
            ${{ secrets.VPS_USER }}@${{ secrets.VPS_HOST }} << 'EOF'
          
          case "${{ matrix.service }}" in
            "auth-service") PORT=3000 ;;
            "user-service") PORT=3001 ;;
            "chat-service") PORT=3002 ;;
            "event-service") PORT=3003 ;;
            "shared-service") PORT=3004 ;;
            "splitz-service") PORT=3005 ;;
          esac
          
          echo "‚è≥ Waiting for ${{ matrix.service }} to be healthy on port \$PORT..."
          
          max_attempts=30
          attempt=1
          
          while [ \$attempt -le \$max_attempts ]; do
            if curl -f -s http://localhost:\$PORT/health > /dev/null 2>&1; then
              echo "‚úÖ ${{ matrix.service }} is healthy!"
              break
            fi
            
            if [ \$attempt -eq \$max_attempts ]; then
              echo "‚ùå ${{ matrix.service }} failed to become healthy"
              docker logs letzgo-${{ matrix.service }} --tail 50
              exit 1
            fi
            
            echo "Attempt \$attempt/\$max_attempts - waiting 10 seconds..."
            sleep 10
            attempt=\$((attempt + 1))
          done
          EOF

      - name: Cleanup SSH
        if: always()
        run: |
          rm -f ~/.ssh/id_rsa

  # ===========================================================================
  # Verify Deployment
  # ===========================================================================
  verify:
    name: Verify Multi-Repo Service Deployment
    runs-on: ubuntu-latest
    needs: [setup, deploy]
    if: needs.setup.outputs.services != '' && !cancelled()
    
    steps:
      - name: Setup SSH
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.VPS_SSH_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          ssh-keyscan -p ${{ secrets.VPS_PORT }} ${{ secrets.VPS_HOST }} >> ~/.ssh/known_hosts

      - name: Verify deployed services
        run: |
          ssh -p ${{ secrets.VPS_PORT }} -o StrictHostKeyChecking=no \
            ${{ secrets.VPS_USER }}@${{ secrets.VPS_HOST }} << 'EOF'
          
          echo "üîç Verifying multi-repository service deployment..."
          
          SERVICES="${{ needs.setup.outputs.services }}"
          IFS=',' read -ra SERVICE_ARRAY <<< "$SERVICES"
          
          healthy_services=0
          total_services=${#SERVICE_ARRAY[@]}
          
          for service in "${SERVICE_ARRAY[@]}"; do
            case "$service" in
              "auth-service") PORT=3000 ;;
              "user-service") PORT=3001 ;;
              "chat-service") PORT=3002 ;;
              "event-service") PORT=3003 ;;
              "shared-service") PORT=3004 ;;
              "splitz-service") PORT=3005 ;;
            esac
            
            if curl -f -s "http://localhost:$PORT/health" > /dev/null; then
              echo "‚úÖ $service is responding on port $PORT"
              healthy_services=$((healthy_services + 1))
            else
              echo "‚ùå $service is not responding on port $PORT"
              docker logs letzgo-$service --tail 20
            fi
          done
          
          echo "üìä $healthy_services out of $total_services services are healthy"
          
          # Show running containers
          echo "üìã Running service containers:"
          docker ps --format "table {{.Names}}\t{{.Status}}\t{{.Ports}}" | grep letzgo-
          
          if [ $healthy_services -eq $total_services ]; then
            echo "üéâ All multi-repository services are healthy!"
          else
            echo "‚ö†Ô∏è  Some services are not healthy"
            exit 1
          fi
          EOF

      - name: Cleanup SSH
        if: always()
        run: |
          rm -f ~/.ssh/id_rsa

  # ===========================================================================
  # Cleanup Artifacts
  # ===========================================================================
  cleanup:
    name: Cleanup Artifacts
    runs-on: ubuntu-latest
    needs: [setup, verify]
    if: always() && needs.setup.outputs.services != ''
    
    strategy:
      matrix: ${{ fromJson(needs.setup.outputs.matrix) }}
    
    steps:
      - name: Delete Docker image artifact
        uses: geekyeggo/delete-artifact@v2
        with:
          name: letzgo-${{ matrix.service }}-image
        continue-on-error: true

  # ===========================================================================
  # Notify Deployment Status
  # ===========================================================================
  notify:
    name: Notify Multi-Repo Deployment Status
    runs-on: ubuntu-latest
    needs: [setup, deploy, verify]
    if: always() && needs.setup.outputs.services != ''
    
    steps:
      - name: Notify success
        if: needs.verify.result == 'success'
        run: |
          echo "‚úÖ Multi-repository service deployment successful!"
          echo "Services deployed: ${{ needs.setup.outputs.services }}"
          echo "Environment: staging"
          echo "VPS: 103.168.19.241"
          echo "Each service was deployed from its separate repository"

      - name: Notify failure
        if: needs.verify.result == 'failure' || needs.deploy.result == 'failure'
        run: |
          echo "‚ùå Multi-repository service deployment failed!"
          echo "Services: ${{ needs.setup.outputs.services }}"
          echo "Please check the deployment logs for details."
