name: CD - Deploy to Production

on:
  push:
    branches: [ main ]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Deployment environment'
        required: true
        default: 'production'
        type: choice
        options:
        - production
        - staging

env:
  NODE_VERSION: '18'
  DEPLOY_PATH: '/opt/letzgo'

jobs:
  # ===========================================================================
  # Build and Push Docker Images
  # ===========================================================================
  build:
    name: Build and Test
    runs-on: ubuntu-latest
    
    outputs:
      version: ${{ steps.version.outputs.version }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Generate version
        id: version
        run: |
          VERSION="v$(date +%Y%m%d-%H%M%S)-${GITHUB_SHA::7}"
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "Generated version: $VERSION"

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: Install dependencies and run tests
        run: |
          services=("auth-service" "user-service" "chat-service" "event-service" "shared-service" "splitz-service")
          for service in "${services[@]}"; do
            echo "Processing $service..."
            cd "$service"
            npm ci
            # Run tests if they exist
            if npm run test --if-present; then
              echo "Tests passed for $service"
            else
              echo "No tests or tests failed for $service"
            fi
            cd ..
          done

      - name: Create deployment archive
        run: |
          # Create a clean deployment package
          mkdir -p /tmp/letzgo-deployment
          
          # Copy all service directories
          cp -r auth-service /tmp/letzgo-deployment/
          cp -r user-service /tmp/letzgo-deployment/
          cp -r chat-service /tmp/letzgo-deployment/
          cp -r event-service /tmp/letzgo-deployment/
          cp -r shared-service /tmp/letzgo-deployment/
          cp -r splitz-service /tmp/letzgo-deployment/
          
          # Copy deployment files
          cp -r deployment/* /tmp/letzgo-deployment/
          
          # Remove node_modules from services to reduce size
          find /tmp/letzgo-deployment -name "node_modules" -type d -exec rm -rf {} + || true
          find /tmp/letzgo-deployment -name ".git" -type d -exec rm -rf {} + || true
          
          # Create tarball
          cd /tmp
          tar -czf letzgo-deployment.tar.gz letzgo-deployment/

      - name: Upload deployment artifact
        uses: actions/upload-artifact@v4
        with:
          name: letzgo-deployment-${{ steps.version.outputs.version }}
          path: /tmp/letzgo-deployment.tar.gz
          retention-days: 30

  # ===========================================================================
  # Deploy to Production
  # ===========================================================================
  deploy:
    name: Deploy to Production VPS
    runs-on: ubuntu-latest
    needs: build
    environment: 
      name: production
      url: http://103.168.19.241
    
    steps:
      - name: Download deployment artifact
        uses: actions/download-artifact@v4
        with:
          name: letzgo-deployment-${{ needs.build.outputs.version }}

      - name: Setup SSH
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.VPS_SSH_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          ssh-keyscan -p ${{ secrets.VPS_PORT }} ${{ secrets.VPS_HOST }} >> ~/.ssh/known_hosts

      - name: Copy files to VPS
        run: |
          scp -P ${{ secrets.VPS_PORT }} -o StrictHostKeyChecking=no \
            letzgo-deployment.tar.gz \
            ${{ secrets.VPS_USER }}@${{ secrets.VPS_HOST }}:/tmp/

      - name: Deploy on VPS
        run: |
          ssh -p ${{ secrets.VPS_PORT }} -o StrictHostKeyChecking=no \
            ${{ secrets.VPS_USER }}@${{ secrets.VPS_HOST }} << 'EOF'
          
          set -e
          
          echo "üöÄ Starting deployment process..."
          
          # Extract deployment files
          cd /tmp
          tar -xzf letzgo-deployment.tar.gz
          
          # Create environment file if it doesn't exist
          if [ ! -f "${{ env.DEPLOY_PATH }}/.env" ]; then
            echo "‚ö†Ô∏è  Creating default environment file..."
            mkdir -p "${{ env.DEPLOY_PATH }}"
            cat > "${{ env.DEPLOY_PATH }}/.env" << 'ENVEOF'
          # Generated environment file - PLEASE UPDATE WITH REAL VALUES
          POSTGRES_PASSWORD=postgres123_change_me
          MONGODB_PASSWORD=mongodb123_change_me
          REDIS_PASSWORD=redis123_change_me
          RABBITMQ_PASSWORD=rabbitmq123_change_me
          JWT_SECRET=jwt_secret_change_me_to_at_least_32_characters_long
          SERVICE_API_KEY=service_api_key_change_me_to_at_least_32_characters_long
          RAZORPAY_KEY_ID=your_razorpay_key_id
          RAZORPAY_KEY_SECRET=your_razorpay_key_secret
          STORAGE_PROVIDER=local
          ENVEOF
            echo "‚ö†Ô∏è  DEFAULT ENVIRONMENT CREATED - PLEASE UPDATE WITH REAL VALUES!"
          fi
          
          # Run deployment script
          cd /tmp/letzgo-deployment
          chmod +x deploy.sh
          ./deploy.sh
          
          echo "‚úÖ Deployment completed successfully!"
          EOF

      - name: Verify deployment
        run: |
          # Wait for services to start
          sleep 60
          
          # Check if services are responding
          ssh -p ${{ secrets.VPS_PORT }} -o StrictHostKeyChecking=no \
            ${{ secrets.VPS_USER }}@${{ secrets.VPS_HOST }} << 'EOF'
          
          echo "üîç Verifying deployment..."
          
          # Check if main services are running
          if curl -f -s http://localhost/health > /dev/null; then
            echo "‚úÖ API Gateway is responding"
          else
            echo "‚ùå API Gateway is not responding"
            exit 1
          fi
          
          # Check individual services
          services=("3000" "3001" "3002" "3003" "3004" "3005")
          for port in "${services[@]}"; do
            if curl -f -s "http://localhost:$port/health" > /dev/null; then
              echo "‚úÖ Service on port $port is responding"
            else
              echo "‚ö†Ô∏è  Service on port $port is not responding"
            fi
          done
          
          # Show running containers
          echo "üìã Running containers:"
          docker ps --format "table {{.Names}}\t{{.Status}}\t{{.Ports}}"
          
          echo "üéâ Deployment verification completed!"
          EOF

      - name: Cleanup
        if: always()
        run: |
          # Clean up SSH key
          rm -f ~/.ssh/id_rsa
          
          # Clean up temporary files on VPS
          ssh -p ${{ secrets.VPS_PORT }} -o StrictHostKeyChecking=no \
            ${{ secrets.VPS_USER }}@${{ secrets.VPS_HOST }} \
            "rm -f /tmp/letzgo-deployment.tar.gz; rm -rf /tmp/letzgo-deployment" || true

  # ===========================================================================
  # Post-deployment notifications
  # ===========================================================================
  notify:
    name: Notify Deployment Status
    runs-on: ubuntu-latest
    needs: [build, deploy]
    if: always()
    
    steps:
      - name: Notify success
        if: needs.deploy.result == 'success'
        run: |
          echo "‚úÖ Deployment successful!"
          echo "Version: ${{ needs.build.outputs.version }}"
          echo "Environment: production"
          echo "URL: http://103.168.19.241"

      - name: Notify failure
        if: needs.deploy.result == 'failure'
        run: |
          echo "‚ùå Deployment failed!"
          echo "Version: ${{ needs.build.outputs.version }}"
          echo "Please check the deployment logs for details."

      # Uncomment and configure these if you want Slack/Discord notifications
      # - name: Slack Notification
      #   if: always()
      #   uses: 8398a7/action-slack@v3
      #   with:
      #     status: ${{ needs.deploy.result }}
      #     webhook_url: ${{ secrets.SLACK_WEBHOOK }}
      
      # - name: Discord Notification
      #   if: always()
      #   uses: sarisia/actions-status-discord@v1
      #   with:
      #     webhook: ${{ secrets.DISCORD_WEBHOOK }}
      #     status: ${{ needs.deploy.result }}
